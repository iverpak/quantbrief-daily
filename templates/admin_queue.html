<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email Queue - StockDigest Admin</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f8f9fa;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
            color: #ffffff;
            padding: 24px 32px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .header-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
            flex-wrap: wrap;
            gap: 12px;
        }

        .header-nav {
            display: flex;
            gap: 16px;
        }

        .header-nav a {
            color: rgba(255,255,255,0.9);
            text-decoration: none;
            font-size: 14px;
            transition: color 0.2s;
        }

        .header-nav a:hover {
            color: #ffffff;
        }

        .countdown {
            font-size: 14px;
            background: rgba(255,255,255,0.1);
            padding: 8px 16px;
            border-radius: 6px;
        }

        .container {
            max-width: 1400px;
            margin: 40px auto;
            padding: 0 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
        }

        .stat-card {
            background: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }

        .stat-value {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .stat-value.success { color: #10b981; }
        .stat-value.danger { color: #ef4444; }
        .stat-value.warning { color: #f59e0b; }
        .stat-value.info { color: #1e40af; }
        .stat-value.cancelled { color: #6b7280; }

        .stat-label {
            font-size: 12px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metrics-panel {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 24px;
            border: 2px solid #bae6fd;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
        }

        .metric-item {
            background: #ffffff;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .metric-label {
            font-size: 11px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .metric-value {
            font-size: 18px;
            font-weight: 700;
            color: #1e40af;
        }

        .global-actions {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-bottom: 32px;
        }

        .global-actions .btn {
            width: 100%;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .btn-primary {
            background: #1e40af;
            color: #ffffff;
        }

        .btn-primary:hover {
            background: #1e3a8a;
        }

        .btn-success {
            background: #10b981;
            color: #ffffff;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-warning {
            background: #f59e0b;
            color: #ffffff;
        }

        .btn-warning:hover {
            background: #d97706;
        }

        .btn-danger {
            background: #ef4444;
            color: #ffffff;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-secondary {
            background: #6b7280;
            color: #ffffff;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-count {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            margin-left: 6px;
        }

        .btn-wrapped {
            padding: 8px 12px;
            min-width: 80px;
            line-height: 1.2;
            font-size: 11px;
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            white-space: normal;
            text-align: center;
        }

        .btn-wrapped-line1 {
            font-size: 10px;
            font-weight: 600;
        }

        .btn-wrapped-line2 {
            font-size: 11px;
            font-weight: 700;
        }

        .ticker-card {
            background: #ffffff;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 16px;
        }

        .ticker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .ticker-info h3 {
            font-size: 20px;
            font-weight: 700;
            color: #1e40af;
            margin-bottom: 4px;
        }

        .ticker-info p {
            font-size: 14px;
            color: #6b7280;
        }

        .status-badge {
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-ready {
            background: #d1fae5;
            color: #065f46;
        }

        .status-failed {
            background: #fee2e2;
            color: #991b1b;
        }

        .status-processing {
            background: #fef3c7;
            color: #92400e;
        }

        .status-sent {
            background: #dbeafe;
            color: #1e40af;
        }

        .status-cancelled {
            background: #f3f4f6;
            color: #4b5563;
        }

        .ticker-meta {
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 16px;
        }

        .ticker-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .empty-state {
            background: #ffffff;
            padding: 60px 24px;
            border-radius: 8px;
            text-align: center;
            color: #6b7280;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üìß Email Queue</h1>
        <div class="header-meta">
            <div class="header-nav">
                <a href="/admin?token={{ token }}">‚Üê Dashboard</a>
                <a href="/admin/test?token={{ token }}">üß™ Test Page</a>
            </div>
            <div class="countdown" id="countdown">Auto-send in: --</div>
        </div>
    </div>

    <div class="container">
        <!-- System Health Metrics -->
        <div class="metrics-panel" id="metrics-panel">
            <h3 style="margin: 0 0 12px 0; color: #1e40af;">‚öôÔ∏è System Health</h3>
            <div class="metrics-grid">
                <div class="metric-item">
                    <div class="metric-label">Worker Status</div>
                    <div class="metric-value" id="metric-worker-status">-</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">Memory Usage</div>
                    <div class="metric-value" id="metric-memory">-</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">Last Activity</div>
                    <div class="metric-value" id="metric-last-activity">-</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">Active Jobs</div>
                    <div class="metric-value" id="metric-active-jobs">-</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">Worker Restarts</div>
                    <div class="metric-value" id="metric-restarts">-</div>
                </div>
            </div>
        </div>

        <!-- Stats -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value success" id="ready-count">-</div>
                <div class="stat-label">Ready to Send</div>
            </div>
            <div class="stat-card">
                <div class="stat-value danger" id="failed-count">-</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value cancelled" id="cancelled-count">-</div>
                <div class="stat-label">Cancelled</div>
            </div>
            <div class="stat-card">
                <div class="stat-value warning" id="processing-count">-</div>
                <div class="stat-label">Processing</div>
            </div>
            <div class="stat-card">
                <div class="stat-value info" id="sent-count">-</div>
                <div class="stat-label">Sent</div>
            </div>
        </div>

        <!-- Global Actions -->
        <div class="global-actions">
            <button class="btn btn-primary" onclick="generateAllReports()">
                üìä GENERATE ALL REPORTS <span class="btn-count" id="btn-generate-count">-</span>
            </button>
            <button class="btn btn-danger" onclick="cancelInProgressRuns()">
                üö´ CANCEL IN PROGRESS RUNS <span class="btn-count" id="btn-cancel-runs-count">-</span>
            </button>
            <button class="btn btn-primary" onclick="rerunAllQueue()">
                üîÑ RE-RUN ALL QUEUE <span class="btn-count" id="btn-rerun-all-count">-</span>
            </button>
            <button class="btn btn-primary" onclick="retryFailedAndCancelled()">
                üîÑ RETRY FAILED & CANCELLED <span class="btn-count" id="btn-retry-count">-</span>
            </button>
            <button class="btn btn-danger" onclick="cancelReadyEmails()">
                ‚õî CANCEL READY EMAILS <span class="btn-count" id="btn-cancel-ready-count">-</span>
            </button>
            <button class="btn btn-warning" onclick="undoCancelReadyEmails()">
                ‚úÖ UNDO CANCEL READY EMAILS <span class="btn-count" id="btn-undo-cancel-count">-</span>
            </button>
            <button class="btn btn-success" onclick="sendAllReady()">
                ‚úâÔ∏è SEND ALL READY EMAILS <span class="btn-count" id="btn-send-count">-</span>
            </button>
            <button class="btn btn-secondary" onclick="clearAllReports()">
                üóëÔ∏è CLEAR ALL REPORTS <span class="btn-count" id="btn-clear-count">-</span>
            </button>
        </div>

        <!-- Ticker List -->
        <div id="ticker-list">
            <div class="empty-state">
                <p>Loading queue...</p>
            </div>
        </div>
    </div>

    <script>
        const token = '{{ token }}';
        let queueStats = {};

        function updateCountdown() {
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 8, 30, 0);

            if (now > today) {
                document.getElementById('countdown').textContent = 'Auto-send time passed';
            } else {
                const diff = today - now;
                const hours = Math.floor(diff / 3600000);
                const minutes = Math.floor((diff % 3600000) / 60000);
                document.getElementById('countdown').textContent =
                    `Auto-send in: ${hours}h ${minutes}m`;
            }
        }

        function formatDate(dateString) {
            if (!dateString) return 'N/A';
            const date = new Date(dateString);
            return date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        async function fetchMetrics() {
            try {
                const response = await fetch('/health');
                const data = await response.json();

                // Worker status
                const workerStatus = data.worker.thread_alive ? '‚úÖ Running' : '‚ùå Dead';
                const workerColor = data.worker.thread_alive ? '#10b981' : '#ef4444';
                document.getElementById('metric-worker-status').textContent = workerStatus;
                document.getElementById('metric-worker-status').style.color = workerColor;

                // Memory usage
                const memoryMB = data.memory ? `${data.memory.toFixed(0)} MB` : 'N/A';
                document.getElementById('metric-memory').textContent = memoryMB;

                // Last activity (from jobs)
                const activeJobs = data.jobs.active || 0;
                document.getElementById('metric-active-jobs').textContent = activeJobs;

                // Recent completions (as a proxy for last activity)
                const recentCompletions = data.jobs.recent_completions || 0;
                const lastActivity = recentCompletions > 0 ? `${recentCompletions} in last 10min` : 'None';
                document.getElementById('metric-last-activity').textContent = lastActivity;

                // Worker restarts (not available in current health endpoint, show as N/A)
                document.getElementById('metric-restarts').textContent = 'N/A';

            } catch (error) {
                console.error('Failed to fetch metrics:', error);
                document.getElementById('metric-worker-status').textContent = 'Error';
                document.getElementById('metric-worker-status').style.color = '#ef4444';
            }
        }

        async function fetchQueueStatus() {
            try {
                const response = await fetch(`/api/queue-status?token=${token}`);
                const data = await response.json();
                queueStats = data; // Store for button counts

                // Update stats
                document.getElementById('ready-count').textContent = data.ready || 0;
                document.getElementById('failed-count').textContent = data.failed || 0;
                document.getElementById('cancelled-count').textContent = data.cancelled || 0;
                document.getElementById('processing-count').textContent = data.processing || 0;
                document.getElementById('sent-count').textContent = data.sent || 0;

                // Update button counts
                updateButtonCounts(data);

                // Update ticker list
                const tickerList = document.getElementById('ticker-list');
                if (!data.tickers || data.tickers.length === 0) {
                    tickerList.innerHTML = '<div class="empty-state"><p>No emails in queue</p></div>';
                    return;
                }

                tickerList.innerHTML = data.tickers.map(ticker => {
                    // Format recipient count (handle both array and count)
                    let recipientCount = 0;
                    if (ticker.recipients) {
                        recipientCount = Array.isArray(ticker.recipients) ? ticker.recipients.length : ticker.recipient_count || 0;
                    }

                    // Build progress bar HTML for active jobs
                    let progressBarHTML = '';
                    if (ticker.source === 'job_queue' && ticker.status === 'processing') {
                        const progress = ticker.progress || 0;
                        const phase = ticker.phase || 'initializing';
                        const minutes = ticker.minutes_running || 0;
                        progressBarHTML = `
                            <div style="margin: 12px 0;">
                                <div style="display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 4px;">
                                    <span style="color: #1e40af; font-weight: 600;">${phase}</span>
                                    <span style="color: #6b7280;">${progress}% ‚Ä¢ ${minutes.toFixed(1)} min</span>
                                </div>
                                <div style="background: #e5e7eb; height: 8px; border-radius: 4px; overflow: hidden;">
                                    <div style="background: linear-gradient(90deg, #1e40af 0%, #3b82f6 100%); height: 100%; width: ${progress}%; transition: width 0.3s;"></div>
                                </div>
                            </div>
                        `;
                    }

                    return `
                        <div class="ticker-card">
                            <div class="ticker-header">
                                <div class="ticker-info">
                                    <h3>${ticker.ticker} - ${ticker.company_name || 'Unknown Company'}</h3>
                                    <p>${recipientCount} recipients ${ticker.source === 'job_queue' ? '‚Ä¢ <span style="color: #1e40af;">LIVE PROCESSING</span>' : ''}</p>
                                </div>
                                <span class="status-badge status-${ticker.status}">${ticker.status}</span>
                            </div>
                            ${progressBarHTML}
                            <div class="ticker-meta">
                                ${ticker.article_count || 0} articles ‚Ä¢ Updated ${formatDate(ticker.updated_at)}
                                ${ticker.error_message ? '<br><span style="color: #ef4444;">Error: ' + ticker.error_message + '</span>' : ''}
                            </div>
                            <div class="ticker-actions">
                                ${ticker.status === 'ready' ? `<button class="btn btn-success btn-sm" onclick="sendTicker('${ticker.ticker}')">‚úâÔ∏è Send</button>` : ''}
                                ${ticker.status === 'ready' ? `<button class="btn btn-warning btn-sm" onclick="cancelTicker('${ticker.ticker}')">‚ùå Cancel</button>` : ''}
                                ${ticker.status === 'failed' || ticker.status === 'cancelled' ? `<button class="btn btn-primary btn-sm" onclick="rerunTicker('${ticker.ticker}')">üîÑ Retry</button>` : ''}
                                ${ticker.status !== 'processing' ? `
                                    <button class="btn btn-secondary btn-sm btn-wrapped" onclick="viewEmail1('${ticker.ticker}')">
                                        <span class="btn-wrapped-line1">QA:</span>
                                        <span class="btn-wrapped-line2">Article</span>
                                    </button>
                                    <button class="btn btn-secondary btn-sm btn-wrapped" onclick="viewEmail2('${ticker.ticker}')">
                                        <span class="btn-wrapped-line1">QA:</span>
                                        <span class="btn-wrapped-line2">Content</span>
                                    </button>
                                    <button class="btn btn-secondary btn-sm btn-wrapped" onclick="viewEmail('${ticker.ticker}')">
                                        <span class="btn-wrapped-line1">VIEW</span>
                                        <span class="btn-wrapped-line2">Email</span>
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (error) {
                console.error('Failed to fetch queue status:', error);
            }
        }

        async function updateButtonCounts(data) {
            const total = (data.ready || 0) + (data.processing || 0) + (data.failed || 0) + (data.cancelled || 0) + (data.sent || 0);
            const failedAndCancelled = (data.failed || 0) + (data.cancelled || 0);

            // Static counts (calculated from queue status)
            document.getElementById('btn-rerun-all-count').textContent = total;
            document.getElementById('btn-retry-count').textContent = failedAndCancelled;
            document.getElementById('btn-cancel-ready-count').textContent = (data.ready || 0) + (data.processing || 0);
            document.getElementById('btn-undo-cancel-count').textContent = data.cancelled || 0;
            document.getElementById('btn-send-count').textContent = data.ready || 0;
            document.getElementById('btn-clear-count').textContent = total;

            // Dynamic count #1: Active users (for Generate All Reports button)
            try {
                const usersResponse = await fetch(`/api/admin/users?token=${token}`);
                const usersData = await usersResponse.json();
                if (usersData.status === 'success') {
                    const activeUserCount = usersData.users.filter(u => u.status === 'active').length;
                    document.getElementById('btn-generate-count').textContent = activeUserCount;
                }
            } catch (error) {
                console.error('Failed to fetch active users count:', error);
                document.getElementById('btn-generate-count').textContent = '?';
            }

            // Dynamic count #2: Active jobs (for Cancel In Progress Runs button)
            try {
                const statsResponse = await fetch(`/jobs/stats`, {
                    headers: {'X-Admin-Token': token}
                });
                const statsData = await statsResponse.json();
                const activeJobs = (statsData.queued || 0) + (statsData.processing || 0);
                document.getElementById('btn-cancel-runs-count').textContent = activeJobs;
            } catch (error) {
                console.error('Failed to fetch active jobs count:', error);
                document.getElementById('btn-cancel-runs-count').textContent = '?';
            }
        }

        async function generateAllReports() {
            if (!confirm('üìä Generate Reports for All Active Users?\n\n‚Ä¢ Processing time: ~30-45 minutes\n‚Ä¢ Emails will be queued with status \'ready\'\n‚Ä¢ Will NOT send automatically\n\nContinue?')) return;

            try {
                const response = await fetch('/api/generate-all-reports', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({token})
                });

                const result = await response.json();
                if (result.status === 'success') {
                    alert(`‚úÖ Processing ${result.ticker_count} unique tickers.\n\nBatch ID: ${result.batch_id}\n\nRefresh this page in 30-60 minutes.`);
                    fetchQueueStatus();
                } else {
                    alert('Error: ' + result.message);
                }
            } catch (error) {
                alert('Failed to generate reports');
            }
        }

        async function cancelInProgressRuns() {
            try {
                // Get active jobs first
                const response = await fetch('/api/cancel-in-progress-runs', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({token})
                });

                const result = await response.json();

                if (result.cancelled_jobs === 0) {
                    alert('‚úÖ No active jobs to cancel!');
                    return;
                }

                const jobsList = result.affected_jobs.slice(0, 5).map(j =>
                    `‚Ä¢ ${j.ticker} - ${j.status} (${j.progress}%, ${j.phase || 'starting'})`
                ).join('\n');

                const confirmMsg = `üö´ Cancel ${result.cancelled_jobs} In-Progress Jobs?\n\n${jobsList}\n${result.affected_jobs.length > 5 ? `... and ${result.affected_jobs.length - 5} more\n\n` : '\n'}Impact:\n‚Ä¢ Jobs will be cancelled\n‚Ä¢ Partial emails will be incomplete\n‚Ä¢ Does NOT affect emails already in \'ready\' status\n\nContinue?`;

                if (!confirm(confirmMsg)) return;

                if (result.status === 'success') {
                    alert(`‚úÖ Cancelled ${result.cancelled_jobs} jobs across ${result.cancelled_batches} batches`);
                    fetchQueueStatus();
                } else {
                    alert('Error: ' + result.message);
                }
            } catch (error) {
                alert('Failed to cancel in-progress runs');
            }
        }

        async function rerunAllQueue() {
            const total = queueStats.ready + queueStats.processing + queueStats.failed + queueStats.cancelled + queueStats.sent;

            if (!confirm(`üîÑ Reprocess ALL ${total} Tickers from Scratch?\n\nAll statuses:\n‚Ä¢ ${queueStats.ready} ready\n‚Ä¢ ${queueStats.processing} processing\n‚Ä¢ ${queueStats.failed} failed\n‚Ä¢ ${queueStats.cancelled} cancelled\n‚Ä¢ ${queueStats.sent} sent\n\nImpact:\n‚Ä¢ Fresh emails generated with latest news\n‚Ä¢ All existing emails replaced\n‚Ä¢ Processing time: ~30-60 minutes\n\nContinue?`)) return;

            try {
                const response = await fetch('/api/rerun-all-queue', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({token})
                });

                const result = await response.json();
                if (result.status === 'success') {
                    alert(`‚úÖ Reprocessing ${result.ticker_count} tickers.\n\nBatch ID: ${result.batch_id}\n\nCheck back in 30-60 minutes.`);
                    fetchQueueStatus();
                } else {
                    alert('Error: ' + result.message);
                }
            } catch (error) {
                alert('Failed to rerun queue');
            }
        }

        async function retryFailedAndCancelled() {
            const failedAndCancelled = queueStats.failed + queueStats.cancelled;

            if (failedAndCancelled === 0) {
                alert('‚úÖ No failed or cancelled tickers to retry!');
                return;
            }

            if (!confirm(`üîÑ Retry ${failedAndCancelled} Failed & Cancelled Tickers?\n\nTickers to reprocess:\n‚Ä¢ ${queueStats.failed} failed\n‚Ä¢ ${queueStats.cancelled} cancelled\n\nImpact:\n‚Ä¢ Only non-ready tickers reprocessed\n‚Ä¢ Ready tickers NOT affected\n‚Ä¢ Processing time: ~15-30 minutes\n\nContinue?`)) return;

            try {
                const response = await fetch('/api/retry-failed-and-cancelled', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({token})
                });

                const result = await response.json();
                if (result.status === 'success') {
                    alert(`‚úÖ Retrying ${result.ticker_count} tickers.\n\nBatch ID: ${result.batch_id}\n\nProcessing time: ~15-30 minutes.`);
                    fetchQueueStatus();
                } else {
                    alert('Error: ' + result.message);
                }
            } catch (error) {
                alert('Failed to retry failed & cancelled');
            }
        }

        async function cancelReadyEmails() {
            const readyAndProcessing = queueStats.ready + queueStats.processing;

            if (readyAndProcessing === 0) {
                alert('‚úÖ No ready emails to cancel!');
                return;
            }

            if (!confirm(`‚õî Cancel ${readyAndProcessing} Ready Emails?\n\n‚ö†Ô∏è This prevents emails from being sent at 8:30am.\n\nReady emails to cancel:\n‚Ä¢ ${queueStats.ready} ready\n‚Ä¢ ${queueStats.processing} processing\n\nImpact:\n‚Ä¢ Status: ready ‚Üí cancelled\n‚Ä¢ Can be restored via "Undo Cancel Ready Emails"\n‚Ä¢ Does NOT affect processing jobs\n\nContinue?`)) return;

            try {
                const response = await fetch('/api/cancel-ready-emails', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({token})
                });

                const result = await response.json();
                if (result.status === 'success') {
                    alert(`‚õî Cancelled ${result.cancelled_count} emails (prevents 8:30am send)`);
                    fetchQueueStatus();
                } else {
                    alert('Error: ' + result.message);
                }
            } catch (error) {
                alert('Failed to cancel ready emails');
            }
        }

        async function undoCancelReadyEmails() {
            const cancelledCount = queueStats.cancelled || 0;

            if (cancelledCount === 0) {
                alert('‚úÖ No cancelled emails to restore!');
                return;
            }

            if (!confirm(`‚úÖ Restore ${cancelledCount} Cancelled Emails?\n\nImpact:\n‚Ä¢ ALL cancelled emails restored to previous status\n‚Ä¢ Some may need reprocessing (use "Retry Failed & Cancelled")\n‚Ä¢ Ready emails eligible for send again\n\nContinue?`)) return;

            try {
                const response = await fetch('/api/undo-cancel-ready-emails', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({token})
                });

                const result = await response.json();
                if (result.status === 'success') {
                    alert(`‚úÖ Restored ${result.restored_count} cancelled emails to previous status`);
                    fetchQueueStatus();
                } else {
                    alert('Error: ' + result.message);
                }
            } catch (error) {
                alert('Failed to restore cancelled emails');
            }
        }

        async function sendAllReady() {
            const readyCount = queueStats.ready || 0;

            if (readyCount === 0) {
                alert('‚úÖ No ready emails to send!');
                return;
            }

            if (!confirm(`‚úâÔ∏è Send ${readyCount} Ready Emails NOW?\n\n‚ö†Ô∏è This action CANNOT be undone.\n\nImpact:\n‚Ä¢ Emails sent immediately to users\' inboxes\n‚Ä¢ Status: ready ‚Üí sent\n‚Ä¢ Personalized unsubscribe links included\n‚Ä¢ You will receive BCC copies\n\nOnly proceed if you\'ve reviewed content.\n\nContinue?`)) return;

            try {
                const response = await fetch('/api/send-all-ready', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({token})
                });

                const result = await response.json();
                if (result.status === 'success') {
                    alert(`‚úÖ Sent ${result.sent_count} emails`);
                    fetchQueueStatus();
                } else {
                    alert('Error: ' + result.message);
                }
            } catch (error) {
                alert('Failed to send emails');
            }
        }

        async function clearAllReports() {
            const total = queueStats.ready + queueStats.processing + queueStats.failed + queueStats.cancelled + queueStats.sent;

            if (total === 0) {
                alert('Queue is already empty.');
                return;
            }

            const deleteWord = prompt(`‚ö†Ô∏è DELETE All ${total} Queue Entries?\n\n‚ö†Ô∏è WARNING: This action CANNOT be undone!\n\nAll queue entries:\n‚Ä¢ ${queueStats.ready} ready\n‚Ä¢ ${queueStats.processing} processing\n‚Ä¢ ${queueStats.failed} failed\n‚Ä¢ ${queueStats.cancelled} cancelled\n‚Ä¢ ${queueStats.sent} sent (history lost!)\n\nQueue will be completely empty.\nDoes NOT cancel running ticker jobs.\n\nType "DELETE" to confirm:`);

            if (deleteWord !== 'DELETE') {
                alert('Cancelled - you must type DELETE exactly');
                return;
            }

            try {
                const response = await fetch('/api/clear-all-reports', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({token})
                });

                const result = await response.json();
                if (result.status === 'success') {
                    alert(`‚úÖ Deleted ${result.deleted_count} queue entries.`);
                    fetchQueueStatus();
                } else {
                    alert('Error: ' + result.message);
                }
            } catch (error) {
                alert('Failed to clear reports');
            }
        }

        function viewEmail(ticker) {
            window.open(`/api/view-email/${ticker}?token=${token}`, '_blank');
        }

        function viewEmail1(ticker) {
            window.open(`/api/view-email-1/${ticker}?token=${token}`, '_blank');
        }

        function viewEmail2(ticker) {
            window.open(`/api/view-email-2/${ticker}?token=${token}`, '_blank');
        }

        async function rerunTicker(ticker) {
            if (!confirm(`Re-run ${ticker}?`)) return;

            try {
                const response = await fetch('/api/rerun-ticker', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({token, ticker})
                });

                const result = await response.json();
                if (result.status === 'success') {
                    alert(`‚úÖ ${ticker} queued for reprocessing`);
                    fetchQueueStatus();
                } else {
                    alert('Error: ' + result.message);
                }
            } catch (error) {
                alert('Failed to re-run ticker');
            }
        }

        async function cancelTicker(ticker) {
            if (!confirm(`Cancel ${ticker}? It will not send at 8:30 AM.`)) return;

            try {
                const response = await fetch('/api/cancel-ticker', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({token, ticker})
                });

                const result = await response.json();
                if (result.status === 'success') {
                    alert(`‚úÖ ${ticker} cancelled`);
                    fetchQueueStatus();
                } else {
                    alert('Error: ' + result.message);
                }
            } catch (error) {
                alert('Failed to cancel ticker');
            }
        }

        async function sendTicker(ticker) {
            if (!confirm(`Send ${ticker} now?`)) return;

            try {
                const response = await fetch('/api/send-ticker', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({token, ticker})
                });

                const result = await response.json();
                if (result.status === 'success') {
                    alert(`‚úÖ ${ticker} sent`);
                    fetchQueueStatus();
                } else {
                    alert('Error: ' + result.message);
                }
            } catch (error) {
                alert('Failed to send ticker');
            }
        }

        // Initial load
        fetchQueueStatus();
        updateCountdown();

        // Initial load
        fetchMetrics();

        // Auto-refresh (5 seconds for real-time job progress)
        setInterval(() => {
            fetchQueueStatus();
            fetchMetrics();
        }, 5000);
        setInterval(updateCountdown, 60000);
    </script>
</body>
</html>
